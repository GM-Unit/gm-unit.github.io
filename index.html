<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GM-Unit Terminal</title>
    <style>
        :root {
            --terminal-green: #00ff41;
            --terminal-dark: #0a0a0a;
            --terminal-dim: #003b00;
            --terminal-red: #ff3333;
            --terminal-orange: #ff9500;
            --flicker-opacity: 0.15;
            --font-size-base: 14px;
            --font-size-title: 18px;
            --font-size-large: 46px;
            --font-size-mobile: 22px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: var(--terminal-dark);
            color: var(--terminal-green);
            font-family: 'Courier New', monospace;
            min-height: 100vh;
            overflow-x: hidden;
            line-height: 1.6;
        }

        /* Flicker Overlay */
        .flicker-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            z-index: 1000;
            animation: flicker 0.1s infinite;
        }

        @keyframes flicker {
            0% { opacity: 0.85; }
            5% { opacity: 0.9; }
            10% { opacity: 0.8; }
            15% { opacity: 0.85; }
            20% { opacity: 0.9; }
            100% { opacity: 0.85; }
        }

        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.1) 50%,
                rgba(0,0,0,0.1)
            );
            background-size: 100% 4px;
            z-index: 999;
        }

        /* Container Layout */
        .terminal-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            padding: 2rem;
            min-height: 100vh;
            position: relative;
            z-index: 1;
        }

        /* Left Panel - Boot & Sections */
        .left-panel {
            max-width: 600px;
        }

        .boot-screen {
            margin-bottom: 2rem;
            opacity: 0;

[...448 lines omitted...]

        // ==========================================
        const CONFIG = {
            // Typing speeds (ms per character)
            bootTypingSpeed: 30,
            sectionTitleSpeed: 50,
            subtextTypingSpeed: 40,

            // Delays between sections (ms)
            bootFadeDelay: 1500,
            sectionDelay: 800,

            // Telemetry update intervals (ms)
            barUpdateInterval: 100,
            numberUpdateInterval: 150,

            // Glitch settings
            glitchChance: 0.008,  // Chance per frame to glitch
            glitchDuration: 650,  // ms

            // Value ranges for telemetry
            ranges: {
                core1: { min: 2200, max: 2800 },
                core2: { min: 2100, max: 2900 },
                optics1: { min: 85, max: 100 },
                optics2: { min: 80, max: 100 },
                mobility: { min: 120, max: 180 },
                targeting: { min: 75, max: 100 },
                syncRatio: { min: 70, max: 100 },
                stability: { min: 80, max: 100 },
                pressure: { min: 40, max: 95 }
            },

            // Status thresholds
            thresholds: {
                sync: { caution: 80, danger: 60 },
                stability: { caution: 85, danger: 70 },
                pressure: { caution: 70, danger: 85 }
            }
        };

        // ==========================================
        // CONTENT - Lore and text content
        // ==========================================
        const CONTENT = {
            bootMessages: [
                "GM-UNIT TERMINAL v3.1.4",
                "Initializing neural link...",
                "Loading cybernetic interface...",
                "Establishing TC connection...",
                "Calibrating frame sensors...",
                "Chess protocol engaged.",
                "Deployment log mounted.",
                "EVA telemetry active.",
                "System ready."
            ],

            sections: {
                cybernetic: {
                    title: "CYBERNETIC SYSTEMS",
                    subtext: "Neural interface connected. Synapse sync at 94.2%. Cybernetic enhancements online. No rejection detected. Pupil dilation normal. Heart rate stable at 72 BPM. Adrenaline levels within expected parameters."
                },
                tcunit: {
                    title: "TC UNIT",
                    subtext: "Tactical computer operational. Target acquisition systems active. Priority targets loaded. No friendly units in field of fire. Thermal signature detection online. Radar sweep complete."
                },
                frame: {
                    title: "FRAME & SENSORS",
                    subtext: "Frame integrity at 100%. Servo motors responsive. Gyroscope calibrated. Environmental sensors active. Atmosphere breathable. Radiation levels minimal. Temperature within normal range."
                },
                chess: {
                    title: "CHESS OPERATIONS",
                    subtext: "Chess protocol engaged. Enemy movements tracked. Predictive algorithms running. No survivors confirmed in operational zone. Tactical advantage maintained. Proceed with caution."
                },
                deployment: {
                    title: "DEPLOYMENT LOG",
                    subtext: "Mission: Operation Iron Fortress. Deployment time: 0342 hours. Unit status: Active. Coordinates locked. Objective: Secure and hold. Rules of engagement: No survivors."
                }
            },

            ironFortress: {
                primary: ["IRON", "FORTRESS"],
                glitch: ["NO", "SURVIVORS"]
            }
        };

        // ==========================================
        // UTILITY FUNCTIONS
        // ==========================================
        function randomInRange(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function randomFloat(min, max) {
            return (Math.random() * (max - min) + min).toFixed(1);
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function typeText(element, text, speed, callback) {
            let index = 0;
            element.classList.add('typing');

            function type() {
                if (index < text.length) {
                    element.textContent = text.substring(0, index + 1);
                    index++;
                    setTimeout(type, speed);
                } else if (callback) {
                    callback();
                }
            }
            type();
        }

        function createVerticalText(words) {
            let html = '';
            const maxLength = Math.max(...words.map(w => w.length));

            for (let row = 0; row < maxLength; row++) {
                html += '<div class="vertical-text">';
                for (const word of words) {
                    const char = word[row] || ' ';
                    html += `<span class="char">${char}</span><br>`;
                }
                html += '</div>';
            }
            return html;
        }

        // ==========================================
        // IRON FORTRESS DISPLAY
        // ==========================================
        class IronFortressDisplay {
            constructor(container) {
                this.container = container;
                this.isGlitching = false;
                this.glitchTimeout = null;
            }

            render(isGlitch = false) {
                const words = isGlitch ? CONTENT.ironFortress.glitch : CONTENT.ironFortress.primary;
                const className = isGlitch ? 'iron-fortress-text no-survivors' : 'iron-fortress-text';

                this.container.innerHTML = `<div class="${className}">${createVerticalText(words)}</div>`;
            }

            show() {
                this.render(false);
                this.container.classList.add('visible');
            }

            async glitch() {
                if (this.isGlitching) return;

                this.isGlitching = true;
                this.render(true);

                const textElement = this.container.querySelector('.no-survivors');
                if (textElement) {
                    textElement.classList.add('glitching');
                }

                await delay(CONFIG.glitchDuration);

                this.render(false);
                this.isGlitching = false;
            }

            startGlitchLoop() {
                const glitchLoop = () => {
                    if (Math.random() < CONFIG.glitchChance) {
                        this.glitch().then(() => {
                            setTimeout(glitchLoop, randomInRange(3000, 8000));
                        });
                    } else {
                        setTimeout(glitchLoop, 1000);
                    }
                };
                setTimeout(glitchLoop, 3000);
            }
        }

        // ==========================================
        // EVA TELEMETRY
        // ==========================================
        class EVATelemetry {
            constructor() {
                this.elements = {
                    core1: document.getElementById('core1'),
                    core2: document.getElementById('core2'),
                    optics1: document.getElementById('optics1'),
                    optics2: document.getElementById('optics2'),
                    mobility: document.getElementById('mobility'),
                    targeting: document.getElementById('targeting'),
                    barSync: document.getElementById('barSync'),
                    barStability: document.getElementById('barStability'),
                    barPressure: document.getElementById('barPressure'),
                    status: document.getElementById('evaStatus')
                };

                this.values = {
                    sync: 85,
                    stability: 90,
                    pressure: 55
                };

                this.barIntervals = [];
                this.numberInterval = null;
            }

            show() {
                document.getElementById('evaPanel').classList.add('visible');
            }

            updateNumber(element, min, max) {
                const value = randomInRange(min, max);
                element.textContent = value;

                if (Math.random() < 0.3) {
                    element.classList.add('flickering');
                    setTimeout(() => element.classList.remove('flickering'), 200);
                }
            }

            updateBar(element, value, type) {
                element.style.width = `${value}%`;

                // Update color based on thresholds
                element.classList.remove('warning', 'danger');

                if (type === 'pressure') {
                    if (value >= CONFIG.thresholds.pressure.danger) {
                        element.classList.add('danger');
                    } else if (value >= CONFIG.thresholds.pressure.caution) {
                        element.classList.add('warning');
                    }
                }
            }

            updateStatus() {
                const { sync, stability, pressure } = this.values;

                // Determine overall status
                let status = 'nominal';
                let statusText = 'SYSTEM NOMINAL';

                if (sync <= CONFIG.thresholds.sync.danger ||
                    stability <= CONFIG.thresholds.stability.danger ||
                    pressure >= CONFIG.thresholds.pressure.danger) {
                    status = 'danger';
                    statusText = 'CRITICAL WARNING';
                } else if (sync <= CONFIG.thresholds.sync.caution ||
                           stability <= CONFIG.thresholds.stability.caution ||
                           pressure >= CONFIG.thresholds.pressure.caution) {
                    status = 'caution';
                    statusText = 'CAUTION: DEVIATION DETECTED';
                }

                // Only update if changed
                if (this.currentStatus !== status) {
                    this.currentStatus = status;
                    this.elements.status.textContent = statusText;
                    this.elements.status.className = `eva-status status-${status}`;
                }
            }

            startUpdates() {
                // Bar fluctuations
                const updateBars = () => {
                    this.values.sync = Math.max(50, Math.min(100,
                        this.values.sync + randomInRange(-3, 3)));
                    this.values.stability = Math.max(60, Math.min(100,
                        this.values.stability + randomInRange(-2, 2)));
                    this.values.pressure = Math.max(30, Math.min(100,
                        this.values.pressure + randomInRange(-2, 2)));

                    this.updateBar(this.elements.barSync, this.values.sync, 'sync');
                    this.updateBar(this.elements.barStability, this.values.stability, 'stability');
                    this.updateBar(this.elements.barPressure, this.values.pressure, 'pressure');
                    this.updateStatus();
                };

                this.barIntervals.push(setInterval(updateBars, CONFIG.barUpdateInterval));

                // Number updates
                const updateNumbers = () => {
                    const ranges = CONFIG.ranges;
                    this.updateNumber(this.elements.core1, ranges.core1.min, ranges.core1.max);
                    this.updateNumber(this.elements.core2, ranges.core2.min, ranges.core2.max);
                    this.updateNumber(this.elements.optics1, ranges.optics1.min, ranges.optics1.max);
                    this.updateNumber(this.elements.optics2, ranges.optics2.min, ranges.optics2.max);
                    this.updateNumber(this.elements.mobility, ranges.mobility.min, ranges.mobility.max);
                    this.updateNumber(this.elements.targeting, ranges.targeting.min, ranges.targeting.max);
                };

                this.numberInterval = setInterval(updateNumbers, CONFIG.numberUpdateInterval);
            }

            stopUpdates() {
                this.barIntervals.forEach(clearInterval);
                clearInterval(this.numberInterval);
            }
        }

        // ==========================================
        // BOOT SEQUENCE
        // ==========================================
        class BootSequence {
            constructor() {
                this.bootScreen = document.getElementById('bootScreen');
                this.systemSections = document.getElementById('systemSections');
            }

            async run() {
                // Type boot messages
                for (const message of CONTENT.bootMessages) {
                    const line = document.createElement('div');
                    line.className = 'boot-line';
                    this.bootScreen.appendChild(line);
                    this.bootScreen.classList.add('visible');

                    await new Promise(resolve => {
                        typeText(line, message, CONFIG.bootTypingSpeed, resolve);
                    });

                    await delay(randomInRange(200, 500));
                }

                // Fade out boot screen
                await delay(CONFIG.bootFadeDelay);
                this.bootScreen.classList.add('fading');

                await delay(1000);
                this.bootScreen.classList.remove('visible');
                this.bootScreen.innerHTML = '';

                // Show system sections
                this.systemSections.classList.add('visible');

                // Animate sections
                await this.animateSections();
            }

            async animateSections() {
                const sectionOrder = ['cybernetic', 'tcunit', 'frame', 'chess', 'deployment'];

                for (const sectionId of sectionOrder) {
                    await this.animateSection(sectionId);
                    await delay(CONFIG.sectionDelay);
                }
            }

            animateSection(sectionId) {
                return new Promise(resolve => {
                    const titleEl = document.getElementById(`title-${sectionId}`);
                    const contentEl = document.getElementById(`content-${sectionId}`);
                    const sectionData = CONTENT.sections[sectionId];

                    // Type title
                    typeText(titleEl, sectionData.title, CONFIG.sectionTitleSpeed, () => {
                        titleEl.classList.add('typed');

                        // Type subtext
                        typeText(contentEl, sectionData.subtext, CONFIG.subtextTypingSpeed, () => {
                            resolve();
                        });
                    });
                });
            }
        }

        // ==========================================
        // INITIALIZATION
        // ==========================================
        document.addEventListener('DOMContentLoaded', async () => {
            const ironFortress = new IronFortressDisplay(
                document.getElementById('ironFortress')
            );
            const telemetry = new EVATelemetry();
            const boot = new BootSequence();

            // Start boot sequence
            await boot.run();

            // Show EVA panel and Iron Fortress
            ironFortress.show();
            telemetry.show();

            // Start telemetry updates
            telemetry.startUpdates();

            // Start glitch loop
            ironFortress.startGlitchLoop();
        });
    </script>
</body>
